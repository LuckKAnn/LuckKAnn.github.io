<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>ConCurrent | Hexo</title><meta name="description" content="ConCurrent"><meta name="keywords" content=""><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="ConCurrent"><meta name="twitter:description" content="ConCurrent"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta property="og:type" content="article"><meta property="og:title" content="ConCurrent"><meta property="og:url" content="http://yoursite.com/2019/11/19/ConCurrent/"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="ConCurrent"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2019/11/19/ConCurrent/"><link rel="next" title="Hello World" href="http://yoursite.com/2019/11/19/hello-world/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Hexo</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">2</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#JAVA高并发程序设计"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">JAVA高并发程序设计</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#第一章-走入并行世界"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">第一章 走入并行世界</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-概念"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">1.2 概念</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-2-1-同步和异步"><span class="toc_mobile_items-number">1.1.1.1.</span> <span class="toc_mobile_items-text">1.2.1 同步和异步</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-3-并发级别"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">1.3 并发级别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-5-回到java"><span class="toc_mobile_items-number">1.1.3.</span> <span class="toc_mobile_items-text">1.5 回到java</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#第二章-JAVA并行程序基础"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">第二章 JAVA并行程序基础</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-线程的基本操作"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">2.2 线程的基本操作</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-3-volatile与java内存模型-JMM"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">2.3 volatile与java内存模型(JMM)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-4线程组"><span class="toc_mobile_items-number">1.2.3.</span> <span class="toc_mobile_items-text">2.4线程组</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-5-守护线程-Daemon"><span class="toc_mobile_items-number">1.2.4.</span> <span class="toc_mobile_items-text">2.5 守护线程(Daemon)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-6-线程优先级"><span class="toc_mobile_items-number">1.2.5.</span> <span class="toc_mobile_items-text">2.6 线程优先级</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-7-synchronized"><span class="toc_mobile_items-number">1.2.6.</span> <span class="toc_mobile_items-text">2.7 synchronized</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-8-隐蔽的错误"><span class="toc_mobile_items-number">1.2.7.</span> <span class="toc_mobile_items-text">2.8 隐蔽的错误</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#第三章-JDK并发包"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">第三章 JDK并发包</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-1-同步控制"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">3.1 同步控制</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-重入锁"><span class="toc_mobile_items-number">1.3.1.1.</span> <span class="toc_mobile_items-text">1. 重入锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-Condition-与重入锁"><span class="toc_mobile_items-number">1.3.1.2.</span> <span class="toc_mobile_items-text">2. Condition 与重入锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#3-信号量-Semaphore"><span class="toc_mobile_items-number">1.3.1.3.</span> <span class="toc_mobile_items-text">3. 信号量(Semaphore)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#4-ReadWriteLock-读写锁"><span class="toc_mobile_items-number">1.3.1.4.</span> <span class="toc_mobile_items-text">4. ReadWriteLock()读写锁</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA高并发程序设计"><span class="toc-number">1.</span> <span class="toc-text">JAVA高并发程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一章-走入并行世界"><span class="toc-number">1.1.</span> <span class="toc-text">第一章 走入并行世界</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-概念"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.2 概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-同步和异步"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.2.1 同步和异步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-并发级别"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.3 并发级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-回到java"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.5 回到java</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二章-JAVA并行程序基础"><span class="toc-number">1.2.</span> <span class="toc-text">第二章 JAVA并行程序基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-线程的基本操作"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.2 线程的基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-volatile与java内存模型-JMM"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.3 volatile与java内存模型(JMM)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4线程组"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.4线程组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-守护线程-Daemon"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.5 守护线程(Daemon)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-线程优先级"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.6 线程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-synchronized"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.7 synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-隐蔽的错误"><span class="toc-number">1.2.7.</span> <span class="toc-text">2.8 隐蔽的错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第三章-JDK并发包"><span class="toc-number">1.3.</span> <span class="toc-text">第三章 JDK并发包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-同步控制"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 同步控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-重入锁"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">1. 重入锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Condition-与重入锁"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">2. Condition 与重入锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-信号量-Semaphore"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3. 信号量(Semaphore)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-ReadWriteLock-读写锁"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">4. ReadWriteLock()读写锁</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png)"><div id="post-info"><div id="post-title"><div class="posttitle">ConCurrent</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2019-11-19<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2019-11-19</time><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>Post View: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="JAVA高并发程序设计"><a href="#JAVA高并发程序设计" class="headerlink" title="JAVA高并发程序设计"></a>JAVA高并发程序设计</h1><blockquote>
<p>葛一鸣 原书第二版</p>
</blockquote>
<h2 id="第一章-走入并行世界"><a href="#第一章-走入并行世界" class="headerlink" title="第一章 走入并行世界"></a>第一章 走入并行世界</h2><h3 id="1-2-概念"><a href="#1-2-概念" class="headerlink" title="1.2 概念"></a>1.2 概念</h3><h4 id="1-2-1-同步和异步"><a href="#1-2-1-同步和异步" class="headerlink" title="1.2.1 同步和异步"></a>1.2.1 同步和异步</h4><p>同步和异步：通常用来形容一次方法调用。</p>
<p>同步: 同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续行为</p>
<p>异步: 异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者可以继续后续操作.而异步方法在另外一个线程中真实的执行</p>
<p>####1.2.2 并发和并行</p>
<p>他们都表示两个或者多个任务一起执行</p>
<p>并发: 偏重于多个任务交替执行</p>
<p>并行: 真正意义上的同时执行 </p>
<ol start="4">
<li><p>临界区: 表示一种公共资源或者说共享数据，可以被多个线程使用。但是每一次只能有一个线程使用它。在并行程序中，临界区资源就是保护的对象。</p>
</li>
<li><p>阻塞和非阻塞: 用来形容多线程间的相互影响</p>
<p>加入某个线程占用了临界区资源，那么其他需要这个资源的线程就只能挂起，这就是阻塞。</p>
</li>
<li><p>死锁、饥饿、活锁</p>
<p>死锁: 各线程互相占用其他线程所需要的资源，导致一直不能释放和执行完成</p>
<p>饥饿: 指某一个或者多个线程因为种种原因而无法获得所需的资源，导致一直无法执行。</p>
<p>活锁: 资源不断在两个线程间跳动，而没有一个线程同时可以拿到所有资源正常执行</p>
</li>
</ol>
<h3 id="1-3-并发级别"><a href="#1-3-并发级别" class="headerlink" title="1.3 并发级别"></a>1.3 并发级别</h3><p>分为: 阻塞、无饥饿、无障碍、无锁、无等待</p>
<ul>
<li><p>阻塞: 一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法执行</p>
<p>可以使用synchronized关键字或者重复锁，得到一个阻塞的线程。该做法在执行后续代码时，需要得到临界区的锁，如果得不到就会挂起等待</p>
<p>这是一种悲观的策略，以保护共享数据为第一优先级</p>
</li>
<li><p>无饥饿: 不管优先级，想要获得资源就得排队</p>
</li>
<li><p>无障碍: 乐观的策略。认为多个线程之间很有可能不会发生冲突。但是一旦检测到冲突，就要对自己所做的修改进行回滚，确保数据安全。</p>
<p>一中可行的实现方法是依赖”一致性标记”来实现。</p>
</li>
<li><p>无锁: 保证必然有一个线程能够在有限步内完成操作离开临界区</p>
</li>
<li><p>无等待: 是无锁的拓展。它要求所有的线程必须在有限步内完成。</p>
</li>
</ul>
<p>###1.4 并行的两个重要定律</p>
<p>串行系统并行化之后的加速比计算</p>
<p>加速比= 优化前耗时/ 优化后系统耗时。</p>
<ol>
<li><p>Amdahl定律</p>
<p><img alt="加速比计算公式" data-src="/2019/11/19/ConCurrent/1574169757479.png" class="lazyload"></p>
<p>其中F表示串行比例，n表示处理器个数，1-F表示并行比例</p>
<p>由这个定律得出，为提高系统的速度，仅仅增加CPU数量不能起很好的效果。需要从跟不上修改程序的串行行为，提高并行化模块比重，然后再增加CPU，才能得到最大的加速比。</p>
</li>
<li><p>Gustafon定律</p>
<p><img alt="Gustafon加速比计算公式" data-src="/2019/11/19/ConCurrent/1574169788980.png" class="lazyload"></p>
<p>从G定律中，可以发现，如果串行比例很小，并行化比例很大，那么加速比就是处理器的个数，只要不断的累加处理器，就能获得更快的速度。</p>
</li>
</ol>
<h3 id="1-5-回到java"><a href="#1-5-回到java" class="headerlink" title="1.5 回到java"></a>1.5 回到java</h3><ol>
<li><p>原子性: int的赋值是原子性的，不可被中断。</p>
<p>但是long型数据不是原子性的，因为其有62位，而32位系统不能保证原子性。</p>
</li>
<li><p>可见性: 指当一个线程修改了某个共享变量的值时，其他线程能否立即知道这个修改</p>
<p>缓存优化或者硬件优化会导致可见性问题，指令重排和编辑器的优化也会。</p>
</li>
<li><p>有序性：程序可以发生指令重排，重排后的指令顺序与原顺序不一定一致</p>
<p>为什么要指令重排: 因为要通过流水线放松来提高CPU的性能。</p>
<p>因为流水线存在，并且有时候由于流水线会发生停顿，停顿是因为数据没有准备好，那么我们可以重排指令顺序，使得停顿期间也有事情可做，这样就发生了指令重排。、</p>
</li>
<li><p>哪些指令不重排: Happen-Before规则</p>
<p><img alt="Happen-before指令重排原则" data-src="/2019/11/19/ConCurrent/1574169808731.png" class="lazyload"></p>
</li>
</ol>
<h2 id="第二章-JAVA并行程序基础"><a href="#第二章-JAVA并行程序基础" class="headerlink" title="第二章 JAVA并行程序基础"></a>第二章 JAVA并行程序基础</h2><p>进程: 线程的母亲。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p>
<p>程序: 是指令、数据及其组织形式的描述。</p>
<p>线程就是轻量级的进程，是程序执行的最小单位。多用多线程而不是多进程进行并发程序设计，是因为线程间的切换和调度成本远小于进程。</p>
<h3 id="2-2-线程的基本操作"><a href="#2-2-线程的基本操作" class="headerlink" title="2.2 线程的基本操作"></a>2.2 线程的基本操作</h3><ol>
<li><p>进程的生命周期</p>
<p><img alt="线程的生命周期" data-src="/2019/11/19/ConCurrent/1574169834216.png" class="lazyload"></p>
</li>
</ol>
<ol start="2">
<li><p>初始线程: 线程的基本操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新建进程</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">//重写run方法，将线程的任务填入</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"t1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">      t1.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上，是创建进程，并使用start()创建一个线程，并让这个线程的run()方法执行</p>
<p>此外，还可以使用Runnable接口，来自定义线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializeThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新建进程</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> InitializeThread());</span><br><span class="line">      t1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"t1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用借口来新建进程，并利用Thread的带参构造方法来定义Thread</p>
</li>
<li><p>终止线程</p>
<p>可以直接使用stop方法，但是该方法太过于暴力，可能会引起数据不一致的问题</p>
<p><img alt="1574169857237" data-src="/2019/11/19/ConCurrent/1574169857237.png" class="lazyload"></p>
</li>
</ol>
<p>   增加一个标志位，并增加一个方法，检测标志位来停止</p>
<ol start="4">
<li><p>线程中断</p>
<p>线程中断不会使线程立即退出，只是给线程发一个通知，告知其被希望结束，但是具体怎么做，由线程决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruputSleepThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Interruted!"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Interruted When Sleep"</span>);</span><br><span class="line">                        <span class="comment">//设置中断状态</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">       Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread.sleep()方法会引起中断，而其中断会清楚中断标记，所以再抛出一次异常。</p>
</li>
<li><p>等待wait和通知notify</p>
<p>这两个方法不是Thread类中的，而是Object类中的。意味着任何对象都可以调用这两个方法。</p>
<p>两个方法都不能随便调用，都要在相应的synchronized语句中，即先获得目标对象的监视器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleWN</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis()+<span class="string">":T1 start! "</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                	System.out.println(System.currentTimeMillis()+<span class="string">":T1 wait for object "</span>);</span><br><span class="line">                    object.wait();<span class="comment">//会释放当前的锁</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis()+<span class="string">":T1 end!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis()+<span class="string">":T2 start! notify one thread"</span>);</span><br><span class="line">                object.notify();</span><br><span class="line">                System.out.println(System.currentTimeMillis()+<span class="string">":T2 end!"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                    不会释放当前的资源，也就是锁，所以T1执行之前，还要等待5s</span></span><br><span class="line">					Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> T1() ;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> T2() ;</span><br><span class="line"><span class="comment">//        Thread t1_1 = new T1() ;</span></span><br><span class="line"><span class="comment">//        t1_1.start();</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>挂起suspend和继续执行resume线程</p>
<p>该两种方法已经被废弃。因为使用suspend挂起时，其还不会释放当前的锁，所以导致其他线程无法执行。并且此时挂起的线程，其状态仍然是Runnable，会影响对系统状态的判断。</p>
</li>
<li><p>等待线程结束join和谦让yeild</p>
<ul>
<li><p>join方法</p>
<p>该方法存在两个实现，一个是无参的join方法，其表示无限等待，会一直阻塞当前线程。另外一个是给出了最大等待时间的。</p>
</li>
<li><p>yield方法</p>
<p>该方法使得当前线程让出CPU</p>
</li>
</ul>
</li>
</ol>
<h3 id="2-3-volatile与java内存模型-JMM"><a href="#2-3-volatile与java内存模型-JMM" class="headerlink" title="2.3 volatile与java内存模型(JMM)"></a>2.3 volatile与java内存模型(JMM)</h3><ul>
<li>volatile 关键字: 表示易变的，不稳定的。该关键字可以保证变量的可见性</li>
<li>该关键字并不能代替锁，也无法保证一些复合操作的原子性。</li>
<li>总的来说，该关键字可以确保一个线程修改了一个数据后，其他线程能够看到这个改动。但当两个线程同时修改一个数据时，仍然会发生冲突。因为两个线程，可以同时拿到上一次修改后的数据的值，然后对其进行加1，然后写回。导致两个线程都只是对原数据进行了加一</li>
</ul>
<h3 id="2-4线程组"><a href="#2-4线程组" class="headerlink" title="2.4线程组"></a>2.4线程组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadGroup tg = <span class="keyword">new</span> ThreadGroup(<span class="string">"PrintGroup"</span>);</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(tg, <span class="keyword">new</span> ThreadGroupName(), <span class="string">"T1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(tg, <span class="keyword">new</span> ThreadGroupName(), <span class="string">"T2"</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">System.out.println(tg.activeCount());</span><br><span class="line">tg.list();</span><br></pre></td></tr></table></figure>

<p>可以如上的方式创建线程组。并将某个线程加入到该线程组中。另外，可以使用actioveCount()方法获得当前线程组中的活动线程数，但是由于线程的状态是动态的，得到的值只是一个大概值。</p>
<p>另外list()方法可以打印线程组中所有线程的信息。</p>
<h3 id="2-5-守护线程-Daemon"><a href="#2-5-守护线程-Daemon" class="headerlink" title="2.5 守护线程(Daemon)"></a>2.5 守护线程(Daemon)</h3><ul>
<li>守护线程: 是一个完成系统性服务的线程。可以主动使用线程的setDaemon方法，设置线程为守护线程。而其他完成用户功能的线程，称为用户线程，当用户线程结束后，守护线程也失去意义，也会结束。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Thread t=<span class="keyword">new</span> DaemonT();</span><br><span class="line">t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>注意，需要在线程start之前，将线程设置为守护线程，否则会报错</p>
<h3 id="2-6-线程优先级"><a href="#2-6-线程优先级" class="headerlink" title="2.6 线程优先级"></a>2.6 线程优先级</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>在java中，使用1-10表示线程优先级，数字越大，优先级越高。</p>
<p>优先级高只是代表线程获得资源的可能性较大，并不能保证一定就比优先级低的线程优先获得资源。</p>
<h3 id="2-7-synchronized"><a href="#2-7-synchronized" class="headerlink" title="2.7 synchronized"></a>2.7 synchronized</h3><ul>
<li>该关键字的作用是实现线程间的同步。</li>
<li>该关键字有多多种用法:<ul>
<li>指定加锁对象: 进入同步代码之前，必须获得该对象的锁</li>
<li>作用于实例方法: 相当于给当前类的实例加锁，进入同步代码之前必须获得该实例的锁</li>
<li>作用于静态方法: 必须获得当前类的锁</li>
</ul>
</li>
</ul>
<p>​    </p>
<h3 id="2-8-隐蔽的错误"><a href="#2-8-隐蔽的错误" class="headerlink" title="2.8 隐蔽的错误"></a>2.8 隐蔽的错误</h3><ul>
<li>并发下的ArrayList<ul>
<li>可能有两种错误: 一个是线程还未扩容成功，另外一个线程就开始了add，导致报错，内存不够。另外一个错误是有可能两线程对arraylist的同一个位置进行了操作。</li>
</ul>
</li>
<li>并发下的HashMap<ul>
<li>也有两种错误。一个同ArrayList相同，两线程重复操作。另外一个在于，操作过程中，可能导致链表成环，从而导致进入死循环</li>
</ul>
</li>
<li>对Integer的错误加锁<ul>
<li>Integer的特性，决定了其值的改变时，每次都会重新创建一个新的对象，赋值给源对象，这导致不同线程加锁的对象可能不是同一个。</li>
</ul>
</li>
</ul>
<h2 id="第三章-JDK并发包"><a href="#第三章-JDK并发包" class="headerlink" title="第三章 JDK并发包"></a>第三章 JDK并发包</h2><h3 id="3-1-同步控制"><a href="#3-1-同步控制" class="headerlink" title="3.1 同步控制"></a>3.1 同步控制</h3><h4 id="1-重入锁"><a href="#1-重入锁" class="headerlink" title="1. 重入锁"></a>1. 重入锁</h4><p>使用ReentrantLock()类来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		System.out.println(<span class="string">"Thread is going on"</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这种使用方法，比synchronized相比，更加的灵活。开发人员必须手动指定何时加锁何时释放锁</p>
</li>
<li><p>一个线程可以连续多次获取到同一把锁，但是相应要释放相应的次数。</p>
</li>
<li><p>中断响应: 使用重入锁时，能够响应中断，在等待锁时，还可以放弃对锁的等待。使用lockInterruptibly()方法来对锁进行请求，可以对中断进行相应。使用interrupt()方法，中断。</p>
</li>
<li><p>限时等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS)</span><br></pre></td></tr></table></figure>

<p>tryLock()方法，接收两个参数，第一个是时长，第二个是单位。另外，不带参数时，表示申请锁，没有得到时，立即返回false</p>
</li>
<li><p>公平锁: 以往选择线程获得资源，都是随机选取的。使用公平锁，会按照先来后到的顺序进行服务。但是此时的性能很低。一般来说，一个线程倾向于再次获得已经持有过的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> 在创建重入锁时，指定是否公平。</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="2-Condition-与重入锁"><a href="#2-Condition-与重入锁" class="headerlink" title="2. Condition 与重入锁"></a>2. Condition 与重入锁</h4><ul>
<li><p>Condition与Object中的wait()方法和notify()方法类似。其有await(), awaitUninterruptibly(), singal()三种方法。</p>
</li>
<li><p>await()用于使得当前线程等待，同时释放当前的锁。等待singal和singalAll唤醒。</p>
</li>
<li><p>awaitUninterruptibly()与上一个类似，但是其不会在等待过程中相应中断，也就是会一直等待</p>
</li>
<li><p>singal（）用于唤醒一个等待中的线程，singalAll()唤醒所有</p>
</li>
<li><p>该对象可以通过重入锁对象进行创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br></pre></td></tr></table></figure>
</li>
<li><p>操纵condition对象时，也需要获得锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line">condition.signal();</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="3-信号量-Semaphore"><a href="#3-信号量-Semaphore" class="headerlink" title="3. 信号量(Semaphore)"></a>3. 信号量(Semaphore)</h4><ul>
<li><p>重入锁和内部锁(synchronized)都一次只允许一个线程访问一个资源，但是新号量允许一次多个线程访问同一个资源</p>
</li>
<li><p>创建方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span></span></span><br></pre></td></tr></table></figure>

<p>创建时，需要指定允许同时访问的线程数，同时还可以指定是否公平。</p>
</li>
<li><p>使用方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>第一个方法用于获得一个准入许可。如果得不到，就会进行等待。</li>
<li>第二个方法与前一个类似，但是不响应中断</li>
<li>第三个方法，尝试获得准入许可，不获得就返回false，不会等待</li>
<li>第四个方法，设置等待时间，尝试在该时间内不断申请</li>
<li>第五个释放资源</li>
</ul>
</li>
</ul>
<h4 id="4-ReadWriteLock-读写锁"><a href="#4-ReadWriteLock-读写锁" class="headerlink" title="4. ReadWriteLock()读写锁"></a>4. ReadWriteLock()读写锁</h4></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/11/19/ConCurrent/">http://yoursite.com/2019/11/19/ConCurrent/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2019/11/19/hello-world/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>Hello World</span></div></a></div></nav></div></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2019 By John Doe</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>